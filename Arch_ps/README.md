# Домашнее задание

##### Условие:
Сравнение разных сборщиков мусора
Написать приложение, которое следит за сборками мусора и пишет в лог количество сборок каждого типа
(young, old) и время которое ушло на сборки в минуту.

Добиться OutOfMemory в этом приложении через медленное подтекание по памяти 
(например добавлять элементы в List и удалять только половину).

Настроить приложение (можно добавлять Thread.sleep(...)) так чтобы оно падало 
с OOM примерно через 5 минут после начала работы.

Собрать статистику (количество сборок, время на сборки) по разным GC.

##### Результаты:
Было проведено несколько запусков приложения с небольшим размером хипа (-Xms256m -Xmx256m) и с увеличенным в 4 раза(-Xms1g -Xmx1g)
для разных вариантов GC (Serial, Parallel, CMS, G1).Параметры GC выбирались VM по умолчанию.Число ядер 4. В приложении используется 
мониторинг работы GC.Некоторые важные параметры оценки работы GC сведены в таблицы.

Таблица для 256m
| GC type  | Young mean/max,ms| Old mean/max,ms  | totalDuration,ms |Young total,n/ms|Old total,n/ms|Elapsed Time,ms| Worker Cycles,n 
|----------|:--------: |:---------: |:--------:|:----------:|:--------------:|:-------:|:------:|
| Serial   |  27/71  | 156/269  | 23797  |205/5594  | 117/18203    |42060  | 135  |
| Parallel |  57/209 | 260/855  | 47189  |381/21996 |  97/25193    |66148  | 136    
| CMS      |  42/121 | 122/425  | 17603  |129/5497  | 100/12106    |29411  | 104
| G1       |  68/421 | 97/172   | 32582  |348/23574 |  93/9008     |57841  | 130
 
Таблица для 1g 
| GC type  | Young mean/max,ms| Old mean/max,ms  | totalDuration,ms |Young total,n/ms|Old total,n/ms|Elapsed Time,ms| Worker Cycles,n 
|----------|:--------: |:---------: |:--------:|:----------:|:--------------:|:-------:|:------:|
| Serial   |   123/374 |  514/1246 | 268561  |    813/100286 |    327/168275 |   478548 |   521
| Parallel |   152/774 |  757/5169 | 494717  |   1705/260685 |    309/234032 |   727251 |   521
| CMS      |   179/616 |  601/1760 | 519313  |   637/114093  |    674/405220 |   754989 |   482
| G1       |   134/480 |  429/844  | 406137  |   2028/271819 |    313/134318 |   829048 |   521 

Таблица распределения по диапазонам для 256m 
| GC type  | GC Pause Duration 0-100 ms,% | GC Pause Duration 100-500 ms,% |
|----------|:-----------------------:|:--------------------:|
| Serial   |     71,7                |         28,3         | 
| Parallel |     63,7                |         32,6         |
| CMS      |     73,4                |         26,6         | 
| G1       |     76,6                |         23,4         |

Таблица распределения по диапазонам для 1g
| GC type  | GC Pause Duration 0-100 ms,% | GC Pause Duration 100-500 ms,% |
|----------|:-----------------------:|:--------------------:|
| Serial   |        29,5     |      58,2       | 
| Parallel |        19,2     |      68,0       |
| CMS      |        34,3     |      37,0       | 
| G1       |        27,9     |      69,5       |
##### Выводы:
  
   Победителем в обоих случаях оказался Serial GC Type, потому что до возникновения исключения OutOfMemoryError он выполнил 
максимальное количество рабочих циклов за меньшее время, чем при других типах GC. Думаю,что при большем количестве ядер показатели
для типов GC, которые используют конкурентность (Parallel,CMS,G1) стали бы лучше.  

![Image of PS](https://github.com/nesteg/otus_db/blob/master/Arch_ps/images/docker_ps_pull.png)

Bla-Bla-Bla

![Image of PS](https://github.com/nesteg/otus_db/blob/master/Arch_ps/images/docker_ps_images.png)




